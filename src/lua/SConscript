import base64
import os
import subprocess
import textwrap
import re

from SCons.Errors import BuildError

Import('env')

# scons does not define __file__
LUA_DIR = os.path.dirname((lambda x: x).func_code.co_filename)
LUA_LIBS_DIR = os.path.join(LUA_DIR, 'lualibs/')


def remove_trailing_slash(s):
    # special case:
    if s == '/':
        return s
    while s.endswith('/'):
        s = s[:-1]
    return s


def build_sources_list(dirs, extn):
    if not extn.startswith('.'):
        extn = '.' + extn

    if not hasattr(dirs, '__iter__'):
        dirs = (dirs,)
    sources = list()

    for f in dirs:
        f = remove_trailing_slash(f)
        sources += [
            "%s/%s" % (f, x) for x in os.listdir(f) if x.endswith(extn)
        ]

    return sources


def get_debug_source(sources):
    out = []
    strlen = 0
    for s in sources:
        # try:
        #     assert isinstance(source, six.string_types)
        # except AssertionError:
        #     raise TypeError("expected string")

        source = str(s)
        with open(source) as f:
            # not adding newlines can cause syntax errors
            # in the concatenated result
            text = f.read() + '\n'
        try:
            subprocess.check_call(['luac', '-p', source])
        except subprocess.CalledProcessError as e:
            raise BuildError(errstr="failed to compiled lua source:%s" % e)
        strlen += len(text)
        out.append(''.join('\\x%s' % base64.b16encode(x) for x in text))

    return ''.join(out), strlen


def get_compiled_source(sources):
    compiled_source_path = os.path.join(LUA_DIR, 'luac.out')
    try:
        subprocess.check_call(
            ['luac', '-o', compiled_source_path, '-s'] +
            [str(source) for source in sources]
        )
    except subprocess.CalledProcessError as e:
        raise BuildError(e)

    with open(compiled_source_path) as f:
        text = f.read()

    return ''.join('\\x%s' % base64.b16encode(x) for x in text), len(text)


def split_escaped(script, seg_length=19):
    match = re.findall(r"\\x[0-9a-f]{2}", script, re.IGNORECASE)
    return ''.join(
        '"%s" \\\n' % ''.join(match[x: x + seg_length])
        for x in range(0, len(match), seg_length)
    ).rstrip('\\\n')


def writeout(path, script, script_len):
    script = split_escaped(script)
    content = textwrap.dedent(
        '''
        #ifndef BMO_LUA_DEFAULT_TEXT_H
        #define BMO_LUA_DEFAULT_TEXT_H
        /*
        This file is autogenerated by the build script and all changes
        will be destroyed.
        To change its contents, edit the Lua scripts in ./lualibs
        */
        static const size_t BMO_LUA_INIT_SCRIPT_LEN = %(script_len)s;
        static const char * BMO_LUA_INIT_SCRIPT = \\
        %(script)s;

        #endif
        ''') % locals()

    with open(path, 'w') as f:
        f.write(content)


def compile_lua_sources(target=None, source=None, env=None):
    if ARGUMENTS.get('release', False):
        script, script_len = get_compiled_source(source)
    else:
        script, script_len = get_debug_source(source)
    writeout(target[0].path, script, script_len)


def embedded_lualibs_header():
    output_header = os.path.join(LUA_DIR, 'lua_default_text.h')
    lua_sources = build_sources_list(LUA_LIBS_DIR, 'lua')

    # The output_header file gets updated when any of the Lua sources change
    env.Depends(output_header, lua_sources)
    env.Command(output_header, lua_sources, compile_lua_sources)


embedded_lualibs_header()
