import base64
import os

from SCons.Errors import BuildError

Import('env')

def raise_for_status(s, msg, except_class=BuildError):
    if s:
        raise except_class(msg)

def remove_trailing_slash(s):
    #special case:
    if s == '/':
        return s
    while s.endswith('/'):
    	s = s[:-1]
    return s

def build_sources_list(dirs, extn):
    if not extn.startswith('.'):
        extn = '.' + extn

    if not hasattr(dirs, '__iter__'):
        dirs=(dirs,)
    sources = list()

    for f in dirs:
        f = remove_trailing_slash(f)
        sources += [f + '/' + x for x in os.listdir(f) if x.endswith(extn)]

    return sources

def get_debug_source(sources):
    out = str()
    strlen = 0
    for source in sources:
        with open(str(source)) as f:
            text = f.read()
            if text:
                raise_for_status(
                    os.system(" luac -p %s" % source),
                    "couldn't parse lua source"
                )
            strlen += len(text)
        out += ''.join(['\\x%s' % base64.b16encode(x) for x in text])

    return out, strlen

def get_compiled_source(sources):
    sources = [str(source) for source in sources]
    raise_for_status(
        os.system('luac -s %s' % ' '.join(sources)),
        "failed to compile Lua source"
    )

    with open(os.path.dirname(os.path.dirname('__file__')) + 'luac.out') as f:
        text = f.read()
    strlen = len(text)
    return ''.join(['\\x%s' % base64.b16encode(x) for x in text]), strlen

def split_escaped(script, seg_length=19):
    import re
    import string
    match = re.findall(r"\\x[0-9a-f]{2}", script, re.IGNORECASE)
    return string.join(['"' + string.join(match[x:x+seg_length], '') + \
        '" \\\n' for x in range(0, len(match), seg_length)], "").rstrip('\\\n')

def writeout(path, script, script_len):
    script = split_escaped(script)
    content = '''#ifndef BMO_LUA_DEFAULT_TEXT_H
#define BMO_LUA_DEFAULT_TEXT_H

const size_t BMO_LUA_INIT_SCRIPT_LEN = %(script_len)s;
const char * BMO_LUA_INIT_SCRIPT = %(script)s;

#endif
''' % locals()
    with open(path, 'w') as f:
        f.write(content)


def compile_lua_sources(target=None, source=None, env=None):
    print('compiling Lua sources...')
    if ARGUMENTS.get('release', False):
        writeout(COMPILED_LUA_OUTFILE, *get_compiled_source(source))
    else:
        writeout(COMPILED_LUA_OUTFILE, *get_debug_source(source))

LUA_DIR = os.path.dirname((lambda x:x).func_code.co_filename)
LUA_LIBS_DIR = os.path.join(LUA_DIR, 'lualibs/')
COMPILED_LUA_OUTFILE = os.path.join(LUA_DIR, 'lua_default_text.h')
ALL_LUA_SOURCES = build_sources_list(LUA_LIBS_DIR, 'lua')

# The control file should be updated when any of the lua sources change
env.Depends(COMPILED_LUA_OUTFILE, ALL_LUA_SOURCES)
env.Command(COMPILED_LUA_OUTFILE, ALL_LUA_SOURCES, compile_lua_sources)

