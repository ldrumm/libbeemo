--[[--
    module: dsp.functional

]]
do

dsp = dsp or {}

local function each(sequence, iter)
--[[--
    Given an iterable of tables, ``sequence`` create and return a proxy object
    which when indexed, does the following:
    __index(x) --> create an array (integer indexed table) of the result of
    applying `__index(x)` to every item in the sequence generated by the
    function ``iter`` (or pairs)  __newindex(x, y) --> set every ``x`` in
    ``sequence`` equal to ``y``. Return ``sequence``  __call(...) try and
    call every item in the sequence as a function with  given arguments -> this
    is essentially map(), but with the added property that the results are
    chainable.

    example:
        MyTable = function(...)
            local number = 1
            return {
                unpack{...},
                function1=function() return number end,
                function2=function() return 1 + self[1] end,
                function3=function() return math.random(), 3* number end
            }
        end
        a, b, c = MyTable{1,2,3}, MyTable{4,5,6}, MyTable{7,8,9}
        mytable =
        each({a, b, c})[1] --> {1,4,7}
]]
    local iter = iter or pairs
    assert(type(sequence) == "table", "table expected")
    return setmetatable({}, {
        __index = function(self, key)
            local t = {}
            for k, v in iter(sequence) do
                t[#t + 1] = v[key]
            end
            return setmetatable(t, getmetatable(self))
        end,
        __newindex = function(self, key, val)
            for _, v in iter(sequence) do
                v[key] = val
            end
            return sequence
        end,
        __call = function(self, ...)
            local t = {}
            for k, v in iter(self) do
                t[#t + 1] = v(...)
            end
            return setmetatable(t, getmetatable(self))
        end
    })
end


local function reduce(func, sequence, default, iter)
--[[--
    Accumulate the result of applying the function ``func`` (of two arguments)
    in sequence to the items of an iterable, ``sequence``, according to the
    traversal rules of the given iterator, ``iter`` (ipairs if not given), to
    reduce the sequence to a single value. For example:

        reduce(function(x, y) return x + y end, {1, 2, 3, 4, 5}) --> 15

    If ``default`` is given, it is prepended to the items list and is returned
    if ``sequence`` is empty.
]]
    if sequence == nil and iter == nil then return default end
    iter = iter or ipairs
    local reduced
    local next, invariant, key = iter(sequence)
    key, reduced = next(invariant, key)
    if key == nil then return default end
    if default then
        reduced = func(default, reduced)
    end

    while key ~= nil do
        key, val = next(invariant, key)
        -- We need to avoid passing nil the user map function, so break early
        if val == nil then break end
        reduced = func(val, reduced)
    end
    return reduced
end


local function map(func, sequence, iter)
--[[--
    According to the traversal rules given by the iterator function ``iter``
     (ipairs if not given), build an integer-indexed table of the results of
    applying the function ``func`` (of one argument) to the items of ``sequence``
    ``iter`` can be any function conforming to lua's iterator protocol.
    If ``func`` is `nil`, the identity function is used, resulting in a shallow
    copy of ``sequence`` with numeric indexes. e.g.:

        map(nil, {a=1, b=2,c=3}, pairs) -> {1, 2, 3}
        map(nil, {6,7,8}) -> {6, 7, 8}
        map(nil, nil, false) ->

]]
    local iter = iter or ipairs
    local func = func or function(x) return x end
    local t = {}

    local val
    local next, inv, key = iter(sequence)

    while key ~= nil do
       key, val = next(inv, key)
       t[#t + 1] = func(val)
    end
    return t
end


local function filter(predicate, sequence, iter, strict_truth)
--[[--
    Traverse the table ``sequence`` using the given iterator ``iter`` (or ipairs),
    and build an integer indexed table of items for which ``predicate(item)`` is
    `true`.
    If ``strict_truth`` then only return items for which predicate(item) == true,
    otherwise use looser thruthiness rules (i.e) `tobool(item)`.
    If ``predicate`` is `nil` then return all items which Lua considers
    implicitly `true`.
]]
    local predicate = predicate or function(x) return x and true or false end
    local iter = iter or ipairs

    local t = {}
    local next, inv, key = iter(sequence)
    while key ~= nil do
        if predicate(val) == true then
            t[#t + 1] = val
        end
    end
    return t
end


local function partial(func, ...)
--[[--
    Partial application of function arguments by closure.
    func: the function to wrap

    usage:

        local function tagify(tag, text)
            return string.format('<%s>%s</%s>', tag, text, tag)
        end
        local bold = partial(tagify, 'strong')
        local italic = partial(tagify, 'em')
        bold(italic('hello')) --> '<em><strong>hello</strong></em>'
]]
    local t = {...}
    return function(...)
        local args = {}
        for k, v in ipairs(t) do args[#args + 1] = v end
        for k, v in ipairs{...} do args[#args + 1] = v end
        return func(unpack(args))
    end
end


local function chain(...)
    local iterables = {...}
    local f, t, k
    local function chain(t, k)
    end
end


local function dropwhile(predicate, iterable, iter)
    local t = {}
    iter = iter or ipairs
    local next, invariant, key = iter(iterable)
    local key, val

    repeat
        key, val = next(invariant, key)
    until key == nil or not predicate(val)
    while key ~= nil do
        t[key] = val
        key, val = next(invariant, key)
    end

    return t
end


local function takewhile(predicate, iterable, iter)
--[[--
    Build the shortest prefix (from left-to-right)
    of items that satisfy the condition ``predicate(item) == true``
    according to the traversal rules of the given ``iterator`` default:ipairs
    If there is no prefix that satisfies the above condition, and empty table
    is returned.
]]
    local t = {}
    iter = iter or ipairs
    local next, invariant, key = iter(iterable)
    local key, val = next(invariant, key)
    while key ~= nil and predicate(val) do
        t[key] = val
        key, val = next(invariant, key)
    end

    return t
end


local function sum(sequence, default, iter)
--[[--
    Accumulate the sum of all items in ``sequence`` according to the
    the traversal rules of the iterator ``iter`` or ``ipairs`` if `nil`.
    Lua's builtin add operator `+` is used, so __add metatamethod
    behaviour is preserved.
]]
    return reduce(
        function(x, y) return x + y end,
        sequence,
        default,
        iter
    )
end


local function product(sequence, default, iter)
    return reduce(
        function(x, y) return x * y end,
        sequence,
        default,
        iter
    )
end


local function min(sequence, iter, default, key)
    return reduce(
        key or function(x, y) --
            if x < y then
                return x
            end
            return y
        end,
        sequence,
        default,
        iter
    )
end


local function max(sequence, iter, default, key)
    return reduce(
        key or function(x, y)
            if x > y then
                return x
            end
            return y
        end,
        sequence,
        default,
        iter
    )
end


local function all(sequence, predicate, iter)
    return reduce(
        predicate and function(x, y) return predicate(x) and predicate(y) end
        or function(x, y) return x and y end,
        sequence,
        iter
    ) and true or false
end


local function any(sequence, predicate, iter)
--[[--
    Check that any item in ``sequence`` evaluates as truthy.
    If ``predicate`` is non-nil, instead check for any item for which
    ``predicate(item) == true``.
    This function will return a boolean after the first match, so all items in
    ``sequence`` may not be evaluated.
]]
    iter = iter or ipairs
    if predicate then
        for _, v in iter(sequence) do
            if predicate(v) then return true end
        end
    else
        for _, v in iter(sequence) do
            if v then return true end
        end
    end
    return false
end


dsp.functional = {
    sum=sum,
    product=product,
    partial=partial,
    any=any,
    all=all,
    max=max,
    min=min,
    filter=filter,
    dropwhile=dropwhile,
    takewhile=takewhile,
    reduce=reduce,
    map=map,
    each=each,
    chain=chain,
}

end
